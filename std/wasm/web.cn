include std.cn
include platform.cn

#if platform Platform.wat64 ==;
include wasm/js.cn

struct (JSObject) JSEvent
  sproc __init__ @str:
    JSTypes.Object !self.type
    init var string JSString
    "new Event(args)" string __js_eval
    JSObject.unwrap dup .object_id !self.object_id drop
  end

  // Properties
  sproc bubbles -> int:
    "bubbles" self.get JSInt.unwrap dup .value swap .free
  end
  sproc cancelable -> int:
    "cancelable" self.get JSInt.unwrap dup .value swap .free
  end
  sproc composed -> int:
    "composed" self.get JSInt.unwrap dup .value swap .free
  end
  sproc current_target -> JSObject:
    "currentTarget" self.get JSObject.unwrap
  end
  sproc default_prevented -> int:
    "defaultPrevented" self.get JSInt.unwrap dup .value swap .free
  end
  sproc event_phase -> @str:
    "eventPhase" self.get JSString.unwrap let string;
    string.value string free
  end
  sproc is_trusted -> int:
    "isTrusted" self.get JSInt.unwrap dup .value swap .free
  end
  sproc target -> JSObject:
    "target" self.get JSObject.unwrap
  end
  sproc time_stamp -> int:
    "timeStamp" self.get let float;
    "Math.round(args)" float __js_eval
    JSInt.unwrap dup .value swap .free
    float.free
  end
  sproc type -> @str:
    "type" self.get JSString.unwrap let string;
    string.value string free
  end

  // Methods
  sproc composed_path -> JSArray:
    "composedPath" self.call_method0 JSArray.unwrap
  end
  sproc prevent_default:
    "preventDefault" self.call_method0 .free
  end
  sproc stop_immediate_propagation:
    "stopImmediatePropagation" self.call_method0 .free
  end
  sproc stop_propagation:
    "stopPropagation" self.call_method0 .free
  end

  static nproc unwrap JSObject self -> JSEvent:
    "Event" self.unwrap_as (JSEvent)
  end
  proc full_unwrap JSValue -> JSEvent:
    JSObject.unwrap JSEvent.unwrap
  end
end

proc event_listener_type JSEvent: drop end
struct (JSObject) JSEventTarget
  sproc add_event_listener @str addr event_listener_type:
    init var listener JSExportedFunction
    init var event JSString
    event listener "addEventListener" self.call_method2 .free
  end

  sproc remove_event_listener @str addr event_listener_type:
    init var listener JSExportedFunction
    init var event JSString
    event listener "removeEventListener" self.call_method2 .free
  end

  sproc dispatch_event JSEvent -> int:
    "dispatchEvent" self.call_method1
    JSInt.unwrap dup .value swap .free
  end

  static nproc unwrap JSObject self -> JSEventTarget:
    "EventTarget" self.unwrap_as (JSEventTarget)
  end
  proc full_unwrap JSValue -> JSEventTarget:
    JSObject.unwrap JSEventTarget.unwrap
  end
end
 
struct (JSEventTarget) JSNode
  // Properties
  sproc base_URI -> @str:
    "baseURI" self.get JSString.unwrap let string;
    string.value string free
  end
  sproc node_name -> @str:
    "nodeName" self.get JSString.unwrap let string;
    string.value string free
  end
  sproc node_type -> int:
    "nodeType" self.get JSInt.unwrap dup .value swap .free
  end
  sproc node_value -> JSValue:
    "nodeValue" self.get
  end
  sproc text_content -> JSValue:
    "textContent" self.get
  end

  // Setters
  sproc !node_value JSValue:
    "nodeValue" self.set
  end
  sproc !text_content @str:
    init var string JSString
    string "textContent" self.set
  end

  // Methods
  sproc has_child_nodes -> int:
    "hasChildNodes" self.call_method0 JSInt.unwrap dup .value swap .free
  end
  sproc normalize:
    "normalize" self.call_method0 .free
  end
  sproc is_equal_node JSNode -> int:
    if dup NULL ptr== do
      drop 
      init var null JSNull null
    else (JSValue) end
    "isEqualNode" self.call_method1 JSInt.unwrap dup .value swap .free
  end
  sproc is_same_node JSNode -> int:
    if dup NULL ptr== do
      drop 
      init var null JSNull null
    else (JSValue) end
    "isSameNode" self.call_method1 JSInt.unwrap dup .value swap .free
  end
  sproc compare_document_position JSNode -> int:
    "compareDocumentPosition" self.call_method1 JSInt.unwrap dup .value swap .free
  end
  sproc contains JSNode -> int:
    if dup NULL ptr== do
      drop 
      init var null JSNull null
    else (JSValue) end
    "contains" self.call_method1 JSInt.unwrap dup .value swap .free
  end
  sproc lookup_prefix JSValue -> JSValue:
    "lookupPrefix" self.call_method1
  end
  sproc lookup_namespace_URI JSValue -> JSValue:
    "lookupNamespaceURI" self.call_method1
  end
  sproc is_default_namespace JSValue -> int:
    "isDefaultNamespace" self.call_method1 JSInt.unwrap dup .value swap .free
  end

  static nproc unwrap JSObject self -> JSNode:
    "Node" self.unwrap_as (JSNode)
  end
  proc full_unwrap JSValue -> JSNode:
    JSObject.unwrap JSNode.unwrap
  end
end

// Properties
sproc [JSNode] first_child -> JSNode:
  "firstChild" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end
sproc [JSNode] is_connected -> int:
  "isConnected" self.get JSInt.unwrap dup .value swap .free
end
sproc [JSNode] last_child -> JSNode:
  "lastChild" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end
sproc [JSNode] next_sibling -> JSNode:
  "nextSibling" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end
sproc [JSNode] owner_document -> JSNode: // TODO: JSDocument return type
  "ownerDocument" self.get JSNode.full_unwrap
end
sproc [JSNode] parent_node -> JSNode:
  "parentNode" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end
sproc [JSNode] parent_element -> JSNode: // TODO: JSElement return type
  "parentElement" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end
sproc [JSNode] previous_sibling -> JSNode:
  "previousSibling" self.get let res;
  if JSTypes.Null res.type == do
    res.free NULL
  else
    res JSNode.full_unwrap
  end
end

// Methods
sproc [JSNode] get_root_node -> JSNode:
  "getRootNode" self.call_method0 JSNode.full_unwrap
end
sproc [JSNode] clone_node int -> JSNode:
  init var deep JSInt
  deep "cloneNode" self.call_method1 JSNode.full_unwrap
end
sproc [JSNode] insert_before JSNode JSNode -> JSNode:
  if dup NULL ptr== do
    drop 
    init var null JSNull null
  else (JSValue) end
  "insertBefore" self.call_method2 JSNode.full_unwrap
end
sproc [JSNode] append_child JSNode -> JSNode:
  "appendChild" self.call_method1 JSNode.full_unwrap
end
sproc [JSNode] replace_child JSNode JSNode -> JSNode:
  "replaceChild" self.call_method2 JSNode.full_unwrap
end
sproc [JSNode] remove_child JSNode -> JSNode:
  "removeChild" self.call_method1 JSNode.full_unwrap
end

struct (JSObject) JSNodeList
  // Properties
  sproc length -> int:
    "length" self.get JSInt.unwrap dup .value swap .free
  end

  // Methods
  sproc item int -> JSNode:
    init var index JSInt
    index "item" self.call_method1 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc entries -> JSObject:
    "entries" self.call_method0 JSObject.unwrap
  end
  sproc keys -> JSObject:
    "keys" self.call_method0 JSObject.unwrap
  end
  sproc values -> JSObject:
    "values" self.call_method0 JSObject.unwrap
  end

  proc __index__ int -> JSNode:
    .item
  end

  static nproc unwrap JSObject self -> JSNodeList:
    "NodeList" self.unwrap_as (JSNodeList)
  end
  proc full_unwrap JSValue -> JSNodeList:
    JSObject.unwrap JSNodeList.unwrap
  end
end

proc for_each_node_type JSNode int NodeList: drop drop drop end
sproc [JSNodeList] for_each addr for_each_node_type:
  init var callback JSExportedFunction
  callback "forEach" self.call_method1 .free
end

sproc [JSNode] child_nodes -> JSNodeList:
  "childNodes" self.get JSNodeList.full_unwrap
end

const JSNodeFilter.FILTER_ACCEPT 1;
const JSNodeFilter.FILTER_REJECT 2;
const JSNodeFilter.FILTER_SKIP 3;

const JSNodeFilter.SHOW_ALL 0xFFFFFFFF;
const JSNodeFilter.SHOW_ELEMENT 0x1;
const JSNodeFilter.SHOW_ATTRIBUTE 0x2;
const JSNodeFilter.SHOW_TEXT 0x4;
const JSNodeFilter.SHOW_CDATA_SECTION 0x8;
const JSNodeFilter.SHOW_PROCESSING_INSTRUCTION 0x40;
const JSNodeFilter.SHOW_COMMENT 0x80;
const JSNodeFilter.SHOW_DOCUMENT 0x100;
const JSNodeFilter.SHOW_DOCUMENT_TYPE 0x200;
const JSNodeFilter.SHOW_DOCUMENT_FRAGMENT 0x400;

struct (JSObject) JSNodeIterator
  // Properties
  sproc root -> JSNode:
    "root" self.get JSNode.full_unwrap
  end
  sproc reference_node -> JSNode:
    "referenceNode" self.get JSNode.full_unwrap
  end
  sproc pointer_before_reference_node -> int:
    "pointerBeforeReferenceNode" self.get JSInt.unwrap dup .value swap .free
  end
  sproc what_to_show -> int:
    "whatToShow" self.get JSInt.unwrap dup .value swap .free
  end
  sproc filter -> JSValue:
    "filter" self.get
  end

  // Methods
  sproc next_node -> JSNode:
    "nextNode" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc previous_node -> JSNode:
    "previousNode" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end

  static nproc unwrap JSObject self -> JSNodeIterator:
    "NodeIterator" self.unwrap_as (JSNodeIterator)
  end
  proc full_unwrap JSValue -> JSNodeIterator:
    JSObject.unwrap JSNodeIterator.unwrap
  end
end

struct (JSObject) JSTreeWalker
  // Properties
  sproc root -> JSNode:
    "root" self.get JSNode.full_unwrap
  end
  sproc what_to_show -> int:
    "whatToShow" self.get JSInt.unwrap dup .value swap .free
  end
  sproc filter -> JSValue:
    "filter" self.get
  end
  sproc current_node -> JSNode:
    "currentNode" self.get JSNode.full_unwrap
  end

  // Setters
  sproc !current_node JSValue:
    "currentNode" self.set
  end

  // Methods
  sproc parent_node -> JSNode:
    "parentNode" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc first_child -> JSNode:
    "firstChild" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc last_child -> JSNode:
    "lastChild" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc next_sibling -> JSNode:
    "nextSibling" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc previous_sibling -> JSNode:
    "previousSibling" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc next_node -> JSNode:
    "nextNode" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc previous_node -> JSNode:
    "previousNode" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end

  static nproc unwrap JSObject self -> JSTreeWalker:
    "TreeWalker" self.unwrap_as (JSTreeWalker)
  end
  proc full_unwrap JSValue -> JSTreeWalker:
    JSObject.unwrap JSTreeWalker.unwrap
  end
end

struct (JSObject) JSDOMTokenList
  // Properties
  sproc length -> int:
    "length" self.get JSInt.unwrap dup .value swap .free
  end
  sproc value -> @str:
    "eventPhase" self.get JSString.unwrap let string;
    string.value string free
  end

  // Methods
  sproc item int -> @str:
    init var index JSInt
    index "item" self.call_method1 let res;
    if JSTypes.Null res.type == do
      res.free -1 NULL
    else
      res JSString.unwrap let string;
      string.value string free
    end
  end
  sproc contains @str -> int:
    init var token JSString
    token "contains" self.call_method1
    JSInt.unwrap dup .value swap .free
  end
  sproc add @str:
    init var token JSString
    token "add" self.call_method1 .free
  end
  sproc add_list [DYNAMIC_ARRAY_SIZE] JSString:
    "add" self.call_method .free
  end
  sproc remove @str:
    init var token JSString
    token "remove" self.call_method1 .free
  end
  sproc remove_list [DYNAMIC_ARRAY_SIZE] JSString:
    "remove" self.call_method .free
  end
  sproc replace @str @str:
    init var new_token JSString
    init var old_token JSString
    old_token new_token "replace" self.call_method2 .free
  end
  sproc supports @str -> int:
    init var token JSString
    token "supports" self.call_method1
    JSInt.unwrap dup .value swap .free
  end
  sproc toggle @str -> int:
    init var token JSString
    token "toggle" self.call_method1
    JSInt.unwrap dup .value swap .free
  end
  sproc toggle2 @str int -> int:
    init var force JSInt
    init var token JSString
    token force "toggle" self.call_method2
    JSInt.unwrap dup .value swap .free
  end
  sproc entries -> JSObject:
    "keys" self.call_method0 JSObject.unwrap
  end
  sproc keys -> JSObject:
    "keys" self.call_method0 JSObject.unwrap
  end
  sproc values -> JSObject:
    "values" self.call_method0 JSObject.unwrap
  end

  proc __index__ int -> @str:
    .item
  end

  static nproc unwrap JSObject self -> JSDOMTokenList:
    "DOMTokenList" self.unwrap_as (JSDOMTokenList)
  end
  proc full_unwrap JSValue -> JSDOMTokenList:
    JSObject.unwrap JSDOMTokenList.unwrap
  end
end

proc for_each_token_type JSString int DOMTokenList: drop drop drop end
sproc [JSDOMTokenList] for_each addr for_each_token_type:
  init var callback JSExportedFunction
  callback "forEach" self.call_method1 .free
end

struct (JSNode) JSCharacterData
  // Properties
  sproc data -> @str:
    "data" self.get JSString.unwrap let string;
    string.value string free
  end
  sproc length -> int:
    "length" self.get JSInt.unwrap dup .value swap .free
  end
  sproc next_element_sibling -> JSNode: // TODO: Element return type
    "nextElementSibling" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  sproc previous_element_sibling -> JSNode: // TODO: Element return type
    "previousElementSibling" self.call_method0 let res;
    if JSTypes.Null res.type == do
      res.free NULL
    else
      res JSNode.full_unwrap
    end
  end
  

  // Setters
  sproc !data @str:
    init var string JSString
    string "data" self.set
  end

  // Methods
  sproc after JSNode:
    token "after" self.call_method1 .free
  end
  sproc after_list [DYNAMIC_ARRAY_SIZE] JSNode:
    "after" self.call_method .free
  end
  sproc before JSNode:
    token "before" self.call_method1 .free
  end
  sproc before_list [DYNAMIC_ARRAY_SIZE] JSNode:
    "before" self.call_method .free
  end
  sproc append_data @str:
    init var data JSString
    data "appendData" self.call_method1 .free
  end
  sproc insert_data int @str:
    init var data JSString
    init var offset JSInt
    offset data "insertData" self.call_method2 .free
  end
  sproc delete_data int int:
    init var count JSInt
    init var offset JSInt
    offset count "deleteData" self.call_method2 .free
  end
  sproc remove:
    "remove" self.call_method0 .free
  end
  sproc replace_data int int @str:
    init var data JSString
    init var count JSInt
    init var offset JSInt
    offset count data "deleteData" self.call_method3 .free
  end
  sproc replace_with JSNode:
    token "replaceWith" self.call_method1 .free
  end
  sproc replace_with_list [DYNAMIC_ARRAY_SIZE] JSNode:
    "replaceWith" self.call_method .free
  end
  sproc substring_data int int:
    init var count JSInt
    init var offset JSInt
    offset count "substringData" self.call_method2 let string;
    string.value string free
  end

  static nproc unwrap JSObject self -> JSCharacterData:
    "CharacterData" self.unwrap_as (JSCharacterData)
  end
  proc full_unwrap JSValue -> JSCharacterData:
    JSObject.unwrap JSCharacterData.unwrap
  end
end

struct (JSCharacterData) JSText
  // Properties
  sproc assigned_slot -> JSNode: // TODO: Element return type(HTMLSlotElement to be exact)
    "assignedSlot" self.get JSNode.full_unwrap
  end
  sproc whole_text -> @str:
    "wholeText" self.get JSString.unwrap let string;
    string.value string free
  end

  // Methods
  sproc split_text int -> JSText:
    init var offset JSInt
    offset "splitText" self.call_method1 JSText.full_unwrap
  end

  static nproc unwrap JSObject self -> JSText:
    "Text" self.unwrap_as (JSText)
  end
  proc full_unwrap JSValue -> JSText:
    JSObject.unwrap JSText.unwrap
  end
end
#endif