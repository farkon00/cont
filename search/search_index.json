{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cont","text":"<p>Cont is a toy language which is best described as:</p> <ul> <li>Concatenative</li> <li>Compiled</li> <li>Statically typed</li> <li>A sprinkle of Object Oriented Programming</li> <li>Written in Python</li> <li>Inspired by Porth</li> </ul>"},{"location":"learn/01-quick-start/","title":"Quick start","text":"<p>Run the following commands to set cont up:</p> <pre><code>$ python3 -V\n Python &gt;=3.10\n\n$ git clone https://github.com/farkon00/cont.git\n$ cd cont\n\n# Install fasm with your package manager, nodejs for testing wasm\n$ sudo apt install fasm nodejs \n$ python3 -m pip install pytest\n$ pytest test.py\n\n$ python3 cont.py &lt;source_code&gt;.cn -r\n</code></pre>"},{"location":"learn/01-quick-start/#hello-world","title":"Hello world","text":"<p>Now let's write our first hello world in cont:</p> <pre><code>include std.cn\n\n\"Hello world\" println\n</code></pre> <p>Now you can run it using the following command:</p> <pre><code>$ python3 cont.py hello_world.cn -r\n</code></pre>"},{"location":"learn/02-basic-operation/","title":"Basic operations","text":""},{"location":"learn/02-basic-operation/#the-stack","title":"The stack","text":"<p>Cont is a stack-based language, which means to perform actions we push parameters onto the stack and pop them for operations. You can read more about stack data structures here.</p> <p>Cont is whitespace significant in most cases, which means it uses whitespaces for separating code: space, new lines etc. To push a number onto the stack we just write it out with whitespaces around.</p> <pre><code>1 2 3 // You have three numbers on the stack: 1, 2 and 3\n-69   // Now you have four numbers: 1, 2, 3 and -69\n</code></pre>"},{"location":"learn/02-basic-operation/#arithmetics","title":"Arithmetics","text":"<p>Cont uses 2 values at the top of the stack to get parameters for an arithmetical operation. For example: If the stack looks like [1 2 3] and you perform an addition, the stack becomes [1 5]. And if the stack is [5 69 42] and you perform a subtraction, it becomes [5 27]</p> <pre><code>// Comments will show the stack state after every line\n1   // [1]\n2 3 // [1 2 3] \n+   // [1 5]\n-   // [-4]\n2 * // [-8]\n</code></pre> <p>There are also integer division and modulo operators, but to use them you will need to include <code>std.cn</code> or <code>core.cn</code>. If you don't want to use these includes, you can use the <code>div</code> operator, it pushes both the integer division result and the remainder onto the stack.</p> <pre><code>include std.cn\n\n4 2 /               // [2]\n7 3 %               // [2 1]\n5 / // Divides 1 by 5: [2 0]\n13 4 div            // [2 0 3 1]\n// 3 is the 12 / 4 result and 1 is the remainder from 13 / 4\n</code></pre>"},{"location":"learn/02-basic-operation/#stack-operations","title":"Stack operations","text":"<p>Sometimes you need to change the element order on the stack. You can use the following stack operations to do that: * dup: <code>a -&gt; a a</code> * drop: <code>a -&gt;</code> * swap: <code>a b -&gt; b a</code> * rot: <code>a b c -&gt; c b a</code> * over: <code>a b -&gt; a b a</code></p> <pre><code>1 2 // [1 2]\nswap // [2 1]\ndup // [2 1 1]\nrot // [1 1 2]\nover // [1 1 2 1]\n+ // [1 1 3]\nswap drop // [1 3]\nswap - // [2] \n</code></pre>"},{"location":"learn/02-basic-operation/#a-useful-note","title":"A useful note","text":"<p>If you want to run the code yourself and maybe experiment with it, you would probably want to see what values are on the stack. You could use the <code>print</code> procedure from <code>std.cn</code> file for that. It would look something like this.</p> <pre><code>include std.cn // Include the print procedure\n\n1 2\nswap print print\n// You would see the following in your terminal:\n// 1\n// 2\n</code></pre>"},{"location":"learn/03-loops-and-conditions/","title":"Loops and conditions","text":""},{"location":"learn/03-loops-and-conditions/#if","title":"If","text":"<p>To make conditional code in cont you use the <code>if</code> keyword. There are two syntaxes for ifs you can use any of them, but the first one is generally recommended.</p> <pre><code>include std.cn\n\nif 1 2 &lt; do // If 1 is smaller than 2\n  42 print // Output the number 42 and a new line into the terminal\nend // End if\n</code></pre> <pre><code>include std.cn\n\n1 2 &lt; if // If 1 is smaller than 2\n  42 print // Output the number 42 and a new line into the terminal\nend // End if\n</code></pre> <p>Ifs take one integer from the stack(or with the first syntax the value gets poped at <code>do</code>). And if the integer is != 0, it executes the code in the block, that ends with the <code>end</code> keyword. Thus comparison operations return integers. There are 6 comparison operation: <code>==</code>, <code>!=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&lt;=</code>.</p>"},{"location":"learn/03-loops-and-conditions/#else","title":"Else","text":"<p><code>else</code> blocks are used to execute code in case of the if condition being 0.</p> <pre><code>5\nif dup 2 % 0 == do // If the number on the stack is even\n  2 +\nelse // If the number is odd\n  1 +\nend\n// We will end up with 6 on the stack\n</code></pre>"},{"location":"learn/03-loops-and-conditions/#type-checking","title":"Type checking","text":"<p>If you experimented with if and if-else you might have encountered a compilation error similar to the following</p> <pre><code>Error foo:7:3: stack has extra elements in different routes of if-else\nTypes: int\n</code></pre> <p>This is an error coming from the type checker. It checks, that branches of the if-else have the same number of elements on the stack and that these elements have the same type(we are going to cover types later). In case there is no <code>else</code>, it checks that types with and without executing the if block are the same.</p>"},{"location":"learn/03-loops-and-conditions/#while","title":"While","text":"<p>While block is the way to create loops and repetition in cont, just as ifs it has two different syntaxes.</p> <pre><code>0\nwhile dup 5 &lt; do\n  dup print\n  1 +\nend\n</code></pre> <pre><code>0\ndup 5 &lt; while\n  dup print\n  1 +\n  dup 5 &lt;\nend\n</code></pre> <p>In the second example <code>end</code> consumes one integer from the stack, if it's != 0 it will start the next iteration.</p> <p>The same type checking rules apply to the while as to the if. The type stack with and without executing while's body must be the same.</p>"},{"location":"learn/04-binds/","title":"Binds","text":"<p>Binds are a way to give a name to a value. Bindings are immutable and can only be changed after they go out of scope. Binds has the following syntax.</p> <pre><code>&lt;values&gt;\nbind &lt;bind_name1&gt; &lt;bind_name2&gt; &lt;bind_name3&gt;:\n  &lt;code here&gt;\nend\n</code></pre> <p>To access bound values you will need to push them onto the stack using their name.</p> <pre><code>1\n// Duplicates 1 on the stack\nbind value:\n  value value\nend\n</code></pre> <p>You can see, that bind will pop the values off the stack and has an ability to bind multiple values.</p> <pre><code>1 2 3\nbind first second third:\n  second first +   // [3]\n  third *          // [9]\n  12 swap - // 12 - 9 [3]\nend\n// Equivalent to dup print \nbind result:\n  result print result\nend\n</code></pre> <p>You might have seen, that some of the examples could have just used stack operations, which you've learned in lesson 2. And yes they could have, but if you have more than 4 values on the stack, then you probably shouldn't use stack operations unless absolutely needed. You can't access anything beyond the 4th element without popping some. Also bind can usually produce cleaner code, so it's recommended, unless you just need to perform 1-2 stack operations.</p>"},{"location":"learn/04-binds/#let-bindings","title":"Let bindings","text":"<p>Sometimes the nesting introduced by bind blocks can be annoying or ugly. In such a case you can use the <code>let</code> keyword, which will bind a value until the end of the current block. So for example</p> <pre><code>1 2 + let res1;\n3 4 + let res2;\nres1 res2 + // 10\n</code></pre> <p>But remember the values will get unbound as soon as the block closes</p> <pre><code>5\nif 4 3 &gt; do\n  1 + let a;\nend\na // compilation error: unknown token\n</code></pre>"},{"location":"learn/04-binds/#examples","title":"Examples","text":"<p>This is the program, that prints the first 50 Fibonacci numbers using a bind inside a while loop.</p> <pre><code>include std.cn\n\n0 print 1 print\n\n0 1 48 \nwhile dup 0 &gt; do\n  bind prev2 prev num:\n    prev\n    prev2 prev +\n    dup print\n    num 1 -\n  end\nend\n</code></pre>"},{"location":"learn/05-procedures/","title":"Procedures","text":"<p>Usually, you want to break up your code into reusable pieces, procedures can help you with that. You might have heard them being called functions or subroutines before. The syntax for procedures looks like this.</p> <pre><code>proc &lt;name&gt; &lt;type_arg1&gt; &lt;type_arg2&gt;... -&gt; &lt;return_arg1&gt; &lt;return_arg2&gt;...:\n  &lt;code&gt;\nend\n</code></pre> <p>There is quite a bit of code there, so let me explain. Firstly we use the keyboard <code>proc</code> to declare a procedure, then we give it a name. After that, we need to provide the information for the type checker. You provide types, that the procedure takes as arguments first and then types, that your procedure will have on the stack at the end of the procedure. For example, if you have <code>int int -&gt; int</code>, that's a type signature for a procedure, that takes two numbers and returns one. Then we use a column to indicate, that signature has ended. Then you put the body of the procedure and close it with the <code>end</code> keyword.</p> <p>An example of a simple procedure:</p> <pre><code>proc reverse_subtract int int -&gt; int:\n  swap -\nend\n</code></pre> <p>But the procedure itself doesn't do anything, we need to call it. We use the name of the procedure to call it.</p> <pre><code>3 6 reverse_subtract // [3]\n1 5 reverse_subtract // [3 4]\nreverse_subtract     // [1]\n</code></pre> <p>As you can see, now you can reuse your code. Now let's look deeper into procedure syntax. Return types are optional, so the definition <code>proc print int: ... end</code> is completely valid if you don't need to return anything. Also, the whole signature is optional if your procedure neither accepts nor returns anything. For example:</p> <pre><code>include std.cn\n\nproc hello_world:\n  \"Hello world\" println // Prints hello world and a new line into the terminal\nend\n\nhello_world hello_world hello_world // Calling the procedure three times\n</code></pre>"},{"location":"learn/05-procedures/#named-procedures","title":"Named procedures","text":"<p>If you want to make the most comfortable argument order for the user of the procedure, sometimes it might be really uncomfortable to use inside the procedure itself. Or sometimes to not deal with the stack you may find yourself using bind right at the beginning of the procedure. Named procedures can solve this problem for you. To use named procedures use the <code>nproc</code> keyword.</p> <pre><code>// Be careful, if you include std.cn the name 2dup will already be taken\nnproc 2dup int first int second -&gt; int:\n  first second first second\nend\n</code></pre> <p>This code is equivalent to</p> <pre><code>proc 2dup int int -&gt; int:\n  bind first second:\n    first second first second\n  end\nend\n</code></pre>"},{"location":"learn/06-variables/","title":"Variables","text":"<p>Variables in cont need to be firstly declared using their type and their name, like this:</p> <pre><code>var &lt;name&gt; &lt;type&gt;\n</code></pre> <p>And then to use a variable value we just use its name. Global variables are zero-initialized</p> <pre><code>include std.cn\n\nvar x int\nvar y int\nx print // 0\ny print // 0\n</code></pre> <p>But variables aren't really usefull unless you can write data into them. For that we use <code>!&lt;name&gt;</code> syntax, for example</p> <pre><code>var a int\nvar b int\n\n12 !a\n3 !b\n\na b + print // 15\n\n2 !b\nb print // 2\n</code></pre>"},{"location":"learn/06-variables/#local-variables","title":"Local variables","text":"<p>If you declare a variable inside a procedure, it will become local. That means it will allocate the variable on every call using the call stack. But the variable won't be zero-initialized on every call.</p> <pre><code>include std.cn\n\nproc print_range int:\n  var curr int\n  !curr\n  while curr 0 &gt; do\n    curr print\n    curr 1 - !curr \n  end\nend\n\n1 print_range\n2 print_range\n4 print_range\n</code></pre>"}]}